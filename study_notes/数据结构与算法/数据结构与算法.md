# 二叉树

## 概念

二叉树节点结构

```java
class Node<V> {
	V value;
	Node left;
	Node right;
}
```



## 非递归遍历

> 先序遍历

① 将头节点入栈

② 从栈中弹出一个节点

③ 打印节点

④ 先将右节点入栈、再将左节点入栈

⑤ 重复上述过程



> 后序遍历

① 将头节点入栈s1

② 从栈s1中弹出一个节点

③ 将节点压入栈s2

④ 先将左节点入栈s1、再将右节点入栈s1

⑤ 重复上述过程

⑥ 从s2中弹出节点，即为后序遍历



头右左->左右头



> 中序遍历

① 将当前节点的所有左节点压栈

② 从栈中弹出一个节点

③ 打印当前节点

④ 当前节点设为当前节点的右节点

⑤ 重复①中的操作



## 二叉搜索树

> 性质

若左子树不空，左子树的节点值均小于根节点的值

若右子树不空，右子树的节点值均大于根节点的值



判断是否为二叉搜索树的方法：中序遍历，如果节点值递增，则该树为二叉搜索树



## 完全二叉树

判断方法：

- 任一节点，有右子树无左子树，返回false
- 如果遇到第一个左右子树不全，后续节点皆为叶节点



# 哈希函数与哈希表

> 特征

1. 输入域无穷，输出域有限
2. 相同输入->相同输出
3. 不同输入可能长生相同输出（哈希碰撞）
4. 离散型、均匀性（即使输入参数有相似特征，哈希函数也可以将其离散到不同位置）



计算方式：
$$
in \stackrel{f}{\rightarrow} hash\_key \stackrel{mode}{\rightarrow} out
$$




# 递归

递归算法的使用条件：

1. 一个问题可以分解为若干个子问题
2. 原问题和子问题除了数据规模不同，基本解法相同
3. 问题存在终止条件



# 贪心算法

> 概念

在某一个标准下，优先考虑最满足标准的样本，最后考虑最不满足标准的样本，最终得到一个答案的算法，叫做贪心算法

不从整体考虑，而在某种层面做出的局部最优解

















